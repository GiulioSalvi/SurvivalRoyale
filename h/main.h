#include "config.h"
#include "includes.h"

/// @brief Integer const to represent rank ace
#define Ace 1
/// @brief Integer const to represent rank two
#define Two 2
/// @brief Integer const to represent rank three
#define Three 3
/// @brief Integer const to represent rank four
#define Four 4
/// @brief Integer const to represent rank five
#define Five 5
/// @brief Integer const to represent rank six
#define Six 6
/// @brief Integer const to represent rank seven
#define Seven 7
/// @brief Integer const to represent rank jack
#define Jack 8
/// @brief Integer const to represent rank queen
#define Queen 9
/// @brief Integer const to represent rank king
#define King 10

/// @brief Integer const to represent suit clubs
#define Clubs 11
/// @brief Integer const to represent suit spades
#define Spades 12
/// @brief Integer const to represent suit diamonds
#define Diamonds 13
/// @brief Integer const to represent suit hearts
#define Hearts 14

#ifndef _MAIN_H_
    #define _MAIN_H_
    /// @brief Defines a structure for the cards.
    typedef struct Card {
        /// @brief The suit of the card.
        unsigned int suit;
        /// @brief The rank of the card.
        unsigned int rank;
    } Card;

    /// @brief Defines a structure for the player's info.
    typedef struct Player {
        /// @brief The player ID.
        unsigned int id;
        /// @brief The current player LPs.
        unsigned int lifePoints;
        /// @brief Flag for recording if the faced down card has been revealed; it can be toggled even if the faced down card has been revealed by the effect of the another player's card.
        bool revealedFacedDownCard;
        /// @brief The faced up card.
        Card facedUpCard;
        /// @brief The faced down card.
        Card facedDownCard;
    } Player;

    /// @brief Defines a structure for the game.
    typedef struct Game {
        /// @brief The amount of players currently alive.
        unsigned int playersCounter;
        /// @brief The amount of LPs currently on the playing field.
        unsigned int lifePointsOnTheField;
        /// @brief The currently alive players vector.
        Player** players;
    } Game;

    /// @brief Generates a random number in the range (inclusive).
    /// @param min The minimum possibly generated value.
    /// @param max The maximum possibly generated value.
    /// @return A random value between min and max (inclusive).
    int randomInt(const int min, const int max);
    /// @brief Asks the number of players to the user.
    /// @return The number of players.
    int askPlayerNumber();
    /// @brief Generates a card.
    /// @return Generates a card with seed and number set to -1.
    Card buildCard();
    /// @brief Generates a deck.
    /// @return Generates a deck of 40 cards, generated by buildCard().
    Card* buildDeck();
    /// @brief Generates a player.
    /// @return Generates a player with player's id to -1. Player's cards are built by buildCard. lifePoints property is unset.
    Player* buildPlayer();
    /// @brief Generates a game with the given number of players.
    /// @param playersCounter The number of players.
    /// @return Generates a game with the given number of players. Players are built by buildPlayer. lifePointsOnTheField field is unset. 
    Game buildGame(int playersCounter);
    /// @brief Frees the cards deck.
    /// @param deck The deck to free.
    void freeDeck(Card* deck);
    /// @brief Frees a player.
    /// @param player The player to free.
    void freePlayer(Player* player);
    /// @brief Free all the players in the vector.
    /// @param players The players vector.
    /// @param playersCounter The number of players.
    void freePlayers(Player** players, int playersCounter);
    /// @brief Frees a game structure.
    /// @param game The game structure to free.
    void freeGame(Game* game);

    /// @brief Generates a deck with cards ordered randomly. It is guaranteed that no duplicated cards occurs in the same deck.
    /// @return The deck generated randomly.
    Card* prepareCardDeck();
    /// @brief Generates a player structure with the given player id and with the given data gave by the game configuration.
    /// @param id The ID of the player.
    /// @param deck The deck from which the cards are given.
    /// @param configuration The game configuration from which data, like default LPs, is taken.
    /// @return The generated player. It may occur that this function, called several times, generates players with the same cards.
    Player* preparePlayer(int id, Card* deck, gameConfiguration configuration);
    /// @brief Generates a game structure with the given players number and with the given data gave by the game configuration.
    /// @param playersCounter The number of players.
    /// @param deck The deck from which the cards are given.
    /// @param configuration The game configuration form which data, like default LPs on the playing field, is taken.
    /// @return The generated game. It is guaranteed that players do not have the same cards.
    Game prepareGame(int playersCounter, Card* deck, gameConfiguration configuration);
    /// @brief Shuffles the deck using Fisher - Yates algorithm.
    /// @param deck The deck shuffled.
    void shuffleDeck(Card* deck);
    /// @brief Handles the current game phase.
    /// @param game Pointer to the game struct.
    /// @return Returns if the game can go on.
    bool handleGamePhase(Game* game);
    /// @brief Determines whether the game is ended.
    /// @param game Pointer to the game struct.
    /// @return True if only player is still alive, false otherwise.
    bool isGameEnded(Game* game);
    /// @brief Applies the effect of the player at the given index in the players vector.
    /// @param game Pointer to the game struct.
    /// @param playerPosition The index of the player in the players vector.
    /// @param facedUpCard Flag for determining if the effect of the faced up card has to be applied, if set to true.
    void applyEffect(Game* game, int playerPosition, bool facedUpCard);
    /// @brief Asks to the player if he wants to reveal the faced down card.
    /// @param card The card that could be revealed.
    /// @return True if the player wants to reveal the faced down card, false otherwise.
    bool revealFacedDownCard(Card card);
    /// @brief Assigns new cards to the player. It is not guaranteed that the old cards might be reassigned to the same player.
    /// @param game Pointer to the game struct.
    /// @param deck The cards deck.
    /// @param configuration The game configuration from which rules about cards assignment is taken.
    void giveCards(Game* game, Card* deck, gameConfiguration configuration);
    /// @brief Announces the dead players.
    /// @param game Pointer to the game struct.
    void announceDeadPlayers(Game* game);
    /// @brief Counts how many dead players there are in the players vector.
    /// @param game Pointer to the game struct.
    /// @return The amount of dead players in the players vector.
    int countDeadPlayers(Game* game);
    /// @brief Removes the dead players from the players vector.
    /// @param game Pointer to the game struct.
    void removeDeadPlayers(Game* game);
    /// @brief Generates via the function buildCard new cards that are given to the players.
    /// @param game Pointer to the game struct.
    void withdrawCards(Game* game);
    /// @brief Announces the winner.
    /// @param player The player who won.
    void announceWinner(Player player);

    /// @brief Checks if a card is present in a deck.
    /// @param deck The deck to check into.
    /// @param card The card to look for.
    /// @return True if the card is present in the deck, false otherwise.
    bool deckHasCard(Card* deck, Card card);
    /// @brief Checks if two cards are equal.
    /// @param card1 A card to compare.
    /// @param card2 A card to compare.
    /// @return True if the cards have the same suit and rank, false otherwise.
    bool cardAreEqual(Card card1, Card card2);
    /// @brief Checks if the cards of a given player have been already given to other players.
    /// @param players The players vector. It does not contain player.
    /// @param playersCounter The number of players in the vector.
    /// @param player The player whose cards are to look for.
    /// @return True if a player in the vector has at least one card equal to the player's one, false otherwise.
    bool cardsWereGiven(Player** players, int playersCounter, Player player);

    /// @brief Waits for the user to press a key without waiting for 'Enter' to be pressed.
    /// @param clear Flag for determining if the screen has to be cleaned, if set to true.
    void Pause(bool clear);
    /// @brief Prints user-friendly the card rank and suit.
    /// @param card The card that has to be printed.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void printCard(Card card, bool newLine);
    /// @brief Prints user-friendly the cards deck.
    /// @param deck The deck that has to be printed.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void printDeck(Card* deck, bool newLine);
    /// @brief Prints user-friendly the card's effect.
    /// @param card The card whose effect has to be printed.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void printCardEffect(Card card, bool newLine);
    /// @brief Prints user-friendly the card revealed from a player.
    /// @param card The card that has been revealed.
    void tellFacedDownCard(Card card);
    /// @brief Prints user-friendly player's info.
    /// @param player The player whose infos have to be printed.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void printPlayer(Player player, bool newLine);
    /// @brief Prints user-friendly the players' infos.
    /// @param game The game which cointains the players.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void printPlayers(Game game, bool newLine);
    /// @brief Prints user-friendly game configuration settings.
    /// @param configuration The game configuration that has to be printed.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void printGameConfiguration(gameConfiguration configuration, bool newLine);
#endif