// Copyright (C) 2025  Giulio Salvi, Jacopo Paradisi
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

/**
 * \file
 * \brief Declaration of game-related constants, definition of game-related structures and functions.
**/

#include "config.h"
#include "includes.h"
#include "logs_configuration.h"

/// @brief Integer const to represent rank ace
#define Ace 1
/// @brief Integer const to represent rank two
#define Two 2
/// @brief Integer const to represent rank three
#define Three 3
/// @brief Integer const to represent rank four
#define Four 4
/// @brief Integer const to represent rank five
#define Five 5
/// @brief Integer const to represent rank six
#define Six 6
/// @brief Integer const to represent rank seven
#define Seven 7
/// @brief Integer const to represent rank jack
#define Jack 8
/// @brief Integer const to represent rank queen
#define Queen 9
/// @brief Integer const to represent rank king
#define King 10

/// @brief Integer const to represent suit clubs
#define Clubs 11
/// @brief Integer const to represent suit spades
#define Spades 12
/// @brief Integer const to represent suit diamonds
#define Diamonds 13
/// @brief Integer const to represent suit hearts
#define Hearts 14

#ifndef _MAIN_H_
    #define _MAIN_H_
    /// @brief Defines a structure for the cards.
    typedef struct Card {
        /// @brief The suit of the card.
        unsigned int suit;
        /// @brief The rank of the card.
        unsigned int rank;
    } Card;

    /// @brief Defines a structure for the player's info.
    typedef struct Player {
        /// @brief The player ID.
        unsigned int id;
        /// @brief The current player LPs.
        unsigned int lifePoints;
        /// @brief Flag for recording if the faced down card has been revealed; it can be toggled even if the faced down card has been revealed by the effect of the another player's card.
        bool revealedFacedDownCard;
        /// @brief The faced up card.
        Card facedUpCard;
        /// @brief The faced down card.
        Card facedDownCard;
    } Player;

    /// @brief Defines a structure for the game.
    typedef struct Game {
        /// @brief The configuration for the game.
        GameConfiguration gameConfiguration;
        /// @brief The configuration for the logs, if the game has to be verbose.
        LogsConfiguration logsConfiguration;
        /// @brief The amount of players currently alive.
        unsigned int playersCounter;
        /// @brief The amount of LPs currently on the playing field.
        unsigned int lifePointsOnTheField;
        /// @brief The currently alive players vector.
        Player** players;
    } Game;

    /// @brief Checks if the terminal size is suitable for the TUI (Terminal User Interface); if the terminal it is too small, it exits with EXIT_TERMINAL_TOO_SMALL exit code. On Windows, it checks if the terminal's host process is supported, otherwise it exits with EXIT_WINDOWS_TERMINAL_HOST_NOT_SUPPORTED exit code.
    void checkTerminal();
    /// @brief On Windows, configures that the terminal such that it supports UTF-8 encoded chars.
    void setupTerminal();
    /// @brief On Windows, it checks if the terminal's host process is supported.
    /// @return True if the terminal's host process is supported, false otherwise.
    bool checkTerminalHost();
    /// @brief Checks if the terminal size is suitable for the TUI (Terminal User Interface).
    /// @return True if the terminal is not too small, false otherwise.
    bool checkTerminalSize();
    /// @brief Generates a random number in the range (inclusive).
    /// @param min The minimum possibly generated value.
    /// @param max The maximum possibly generated value.
    /// @return A random value between min and max (inclusive).
    int randomInt(const int min, const int max);
    /// @brief Asks the number of players to the user.
    /// @return The number of players.
    int askPlayerNumber();
    /// @brief Generates a card.
    /// @return Generates a card with seed and number set to -1.
    Card buildCard();
    /// @brief Generates a deck.
    /// @return Generates a deck of 40 cards, generated by buildCard().
    Card* buildDeck();
    /// @brief Generates a player.
    /// @return Generates a player with player's id to -1. Player's cards are built by buildCard. lifePoints property is unset.
    Player* buildPlayer();
    /// @brief Generates a game with the given number of players.
    /// @param playersCounter The number of players.
    /// @return Generates a game with the given number of players. Players are built by buildPlayer. lifePointsOnTheField field is unset. 
    Game buildGame(int playersCounter);
    /// @brief Frees the cards deck.
    /// @param deck The deck to free.
    void freeDeck(Card* deck);
    /// @brief Frees a player.
    /// @param player The player to free.
    void freePlayer(Player* player);
    /// @brief Free all the players in the vector.
    /// @param players The players vector.
    /// @param playersCounter The number of players.
    void freePlayers(Player** players, int playersCounter);
    /// @brief Frees a game structure.
    /// @param game The game structure to free.
    void freeGame(Game* game);

    /// @brief Generates a deck with cards ordered randomly. It is guaranteed that no duplicated cards occurs in the same deck.
    /// @return The deck generated randomly.
    Card* prepareCardDeck();
    /// @brief Generates a player structure with the given player id and with the given data gave by the game configuration.
    /// @param id The ID of the player.
    /// @param deck The deck from which the cards are given.
    /// @param configuration The game configuration from which data, like default LPs, is taken.
    /// @return The generated player. It may occur that this function, called several times, generates players with the same cards.
    Player* preparePlayer(int id, Card* deck, GameConfiguration configuration);
    /// @brief Generates a game structure with the given players number and with the given data gave by the game configuration.
    /// @param playersCounter The number of players.
    /// @param deck The deck from which the cards are given.
    /// @param gameConfiguration The game configuration form which data, like default LPs on the playing field, is taken.
    /// @param logsConfiguration The logs configuration to append to the generated game structure.
    /// @return The generated game. It is guaranteed that players do not have the same cards.
    Game prepareGame(int playersCounter, Card* deck, GameConfiguration gameConfiguration, LogsConfiguration logsConfiguration);
    /// @brief Shuffles the deck using Fisher - Yates algorithm.
    /// @param deck The deck shuffled.
    void shuffleDeck(Card* deck);
    /// @brief Handles the current game phase.
    /// @param game Pointer to the game struct.
    /// @return Returns if the game can go on.
    bool handleGamePhase(Game* game);
    /// @brief Determines whether the game is ended.
    /// @param game Pointer to the game struct.
    /// @return True if only player is still alive, false otherwise.
    bool isGameEnded(Game* game);
    /// @brief Applies the effect of the player at the given index in the players vector.
    /// @param game Pointer to the game struct.
    /// @param playerPosition The index of the player in the players vector.
    /// @param facedUpCard Flag for determining if the effect of the faced up card has to be applied, if set to true.
    /// @return If the game is using TUI, returns true if the function has printed something, otherwise false. If it game is not in TUI, returns false.
    bool applyEffect(Game* game, int playerPosition, bool facedUpCard);
    /// @brief Asks to the player if he wants to reveal the faced down card.
    /// @param card The card that could be revealed.
    /// @return True if the player wants to reveal the faced down card, false otherwise.
    bool revealFacedDownCard(Card card);
    /// @brief Assigns new cards to the player. It is not guaranteed that the old cards might be reassigned to the same player.
    /// @param game Pointer to the game struct.
    /// @param deck The cards deck.
    void giveCards(Game* game, Card* deck);
    /// @brief Announces the dead players.
    /// @param game Pointer to the game struct.
    void announceDeadPlayers(Game* game);
    /// @brief Counts how many dead players there are in the players vector.
    /// @param game Pointer to the game struct.
    /// @return The amount of dead players in the players vector.
    int countDeadPlayers(Game* game);
    /// @brief Removes the dead players from the players vector.
    /// @param game Pointer to the game struct.
    void removeDeadPlayers(Game* game);
    /// @brief Generates via the function buildCard new cards that are given to the players.
    /// @param game Pointer to the game struct.
    void withdrawCards(Game* game);
    /// @brief Announces the winner.
    /// @param player The player who won.
    void announceWinner(Player player);

    /// @brief Checks if a card is present in a deck.
    /// @param deck The deck to check into.
    /// @param card The card to look for.
    /// @return True if the card is present in the deck, false otherwise.
    bool deckHasCard(Card* deck, Card card);
    /// @brief Checks if two cards are equal.
    /// @param card1 A card to compare.
    /// @param card2 A card to compare.
    /// @return True if the cards have the same suit and rank, false otherwise.
    bool cardAreEqual(Card card1, Card card2);
    /// @brief Checks if the cards of a given player have been already given to other players.
    /// @param players The players vector. It does not contain player.
    /// @param playersCounter The number of players in the vector.
    /// @param player The player whose cards are to look for.
    /// @return True if a player in the vector has at least one card equal to the player's one, false otherwise.
    bool cardsWereGiven(Player** players, int playersCounter, Player player);

    /// @brief Prints user-friendly the card revealed from a player.
    /// @param card The card that has been revealed.
    /// @param playerId The player ID.
    /// @param facedUp Flag for determining if the card was faced up, if set to true.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void revealCard(Card card, int playerId, bool facedUp, bool newLine);
    /// @brief Prints user-friendly the card's effect.
    /// @param card The card whose effect has to be printed.
    /// @param newLine Flag for determining if the function has to go to a new line before exiting.
    void printCardEffect(Card card, bool newLine);
    /// @brief Prints user-friendly the faced down card revealed of the player.
    /// @param card The faced down card.
    /// @param playerId The card's owner ID. If it is 0, it prints 'Your', otherwise it prints 'Player <playerID>'s'
    void tellFacedDownCard(Card card, int playerId);
#endif